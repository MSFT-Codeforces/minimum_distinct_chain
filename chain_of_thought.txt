**[section_01]**
Clarify the definitions and requirements.
**[atomic_01_01]**
Each test case provides integers $n$ and $K$ and a string $s$ of length $n$ consisting only of $\texttt{"<"}$ and $\texttt{">"}$. The brightness array must have length $n+1$, corresponding to lanterns numbered $1$ through $n+1$.
**[atomic_01_02]**
Every lantern brightness $a_i$ must be an integer within the closed interval $[1,K]$. Even if inequalities can be satisfied, any value outside this range makes the entire array invalid.
**[atomic_01_03]**
The string $s$ enforces strict adjacent comparisons. For each position $i$ with $1 \le i \le n$:
- if $s_i=\texttt{<}$ then $a_i<a_{i+1}$,
- if $s_i=\texttt{>}$ then $a_i>a_{i+1}$.
No equality is allowed between adjacent lanterns.
**[atomic_01_04]**
An array is valid if it satisfies all range constraints and all $n$ strict inequalities. If any single inequality fails, the whole array is invalid; there is no partial credit or relaxation.
**[atomic_01_05]**
The cost of an array is defined as the number of distinct integer values appearing among $a_1,\dots,a_{n+1}$. For example, $[2,5,2,5]$ has cost $2$, and $[1,2,3]$ has cost $3$.
**[atomic_01_06]**
Among all valid arrays, $c_{\min}$ is the minimum achievable cost. The task is not to output $c_{\min}$ itself, but to count how many valid arrays attain this minimum cost.
**[atomic_01_07]**
For each test case, the output is the number of valid arrays with cost exactly $c_{\min}$, taken modulo $10^9+7$. If no valid array exists for the test case, the required output is $0$.

---

**[section_02]**
Analyze the provided sample test cases and reason about useful edge cases.
**[atomic_02_01]**
The first example provides $n=8$, $K=3$, $s="><>><<>>"$. To analyze this, we first identify the consecutive runs: $>$ (length $1$), $<$ (length $1$), $>>$ (length $2$), $<<$ (length $2$), $>>$ (length $2$). The maximum run length is $2$. A run of $m$ identical characters forces a strictly monotone sequence of $m+1$ consecutive elements, requiring $m+1$ distinct values. Since the endpoint of each run also serves as the start of the adjacent run, direction changes allow monotone segments to share boundary values without demanding additional distinct levels beyond what the longest run requires. In this example, the longest run has length $2$, which by itself forces $3$ distinct values. No pairing of shorter runs demands more. The minimum distinct count is therefore
$$
d=2+1=3.
$$

Since $K=3=d$, the value set is uniquely determined as $\{1,2,3\}$ and the count depends entirely on how many valid rank assignments exist.

This observation suggests a counting decomposition: choosing which $d$ values from $[1,K]$ to use (a binomial coefficient) and counting valid rank patterns that use all chosen values. Here $\binom{3}{3}=1$, so the answer equals the number of valid rank patterns, which is $3$.
**[atomic_02_02]**
The second example has four test cases probing different regimes. The first ($n=1$, $K=1$, $s=">"$) is the simplest infeasibility check: $a_1>a_2$ is impossible when both values must be $1$.

This confirms that the solution handles $K<d$ (here $d=2>1=K$) by outputting $0$, and also validates that the array length is correctly interpreted as $n+1=2$, not $n$.

This corner case does not invalidate the structural decomposition identified above, but it establishes a necessary feasibility precondition: any approach must verify $K \ge d$ before attempting to count arrays.
**[atomic_02_03]**
The second test case ($n=3$, $K=4$, $s=">>>"$) has a single run of length $3$, giving $d=4$. With $K=4=d$, the only possible value set is $\{1,2,3,4\}$ and the strict decreasing constraint pins the unique array $(4,3,2,1)$. This tests the boundary case where $K$ exactly equals $d$ and the monotone constraint is so strong that only one rank pattern exists ($g(d)=1$), making the answer $\binom{4}{4}\cdot 1=1$.
**[atomic_02_04]**
The third test case ($n=4$, $K=2$, $s="<><>"$) has an alternating pattern where every run has length $1$, so $d=2$. With $K=2$, the values $\{1,2\}$ are forced. The alternating constraints $a_1<a_2>a_3<a_4>a_5$ pin each odd-indexed position to $1$ and each even-indexed position to $2$, yielding the unique array $(1,2,1,2,1)$. This tests whether the solution correctly handles rapid direction changes and identifies that alternation still permits a small minimum distinct count.
**[atomic_02_05]**
The fourth test case ($n=6$, $K=3$, $s="><<>>>"$) contains runs of lengths $1$, $2$, and $3$. The maximum run length $3$ gives $d=4$, but $K=3<4$, so no valid array exists. This tests infeasibility caused by an insufficient range rather than by $K=1$. The distinction matters because a solution that only checks $K<2$ as a special case would miss this. It also demonstrates that the relevant bottleneck is the longest run, not the total pattern length. No revision of the structural reasoning from earlier chains is needed; the feasibility check $K \ge d$ correctly handles this case as a pre-computation step in any approach.
**[atomic_02_06]**
To explore beyond the provided examples, consider $n=2$, $K=3$, $s="<>"$. The maximum run length is $1$, so $d=2$ and $\binom{3}{2}=3$ choices of value pairs. For any pair $\{x_1,x_2\}$ with $x_1<x_2$, the constraints $a_1<a_2>a_3$ force $a_2=x_2$ (the peak must be the larger value) and both $a_1,a_3$ must be less than $a_2$, so $a_1=a_3=x_1$. Only one rank pattern works, giving $g(2)=1$ and an answer of $3\cdot 1=3$. This reveals that peaks and valleys tightly constrain rank assignments even in short patterns.
**[atomic_02_07]**
Another instructive case is $n=3$, $K=5$, $s="<<>"$. The run structure is $<<$ (length $2$) then $>$ (length $1$), giving $d=3$ and $\binom{5}{3}=10$ value choices. For any chosen triple $\{x_1<x_2<x_3\}$, the constraints $a_1<a_2<a_3>a_4$ force the first three positions to the unique increasing assignment $(x_1,x_2,x_3)$, while $a_4$ only needs $a_4<a_3=x_3$. Since $a_4$ must come from $\{x_1,x_2,x_3\}$ and be strictly less than $x_3$, we have $a_4 \in \{x_1,x_2\}$, giving $2$ valid rank patterns. So $g(3)=2$ and the answer is $10\cdot 2=20$. This demonstrates that monotone runs fix most positions while boundary positions may retain some freedom.
**[atomic_02_08]**
For stress-testing modular arithmetic, consider $n=1$, $K=10^9$, $s="<"$. Here $d=2$ and the answer is $\binom{10^9}{2}\cdot g(2)$. Since $10^9 \equiv -7\pmod{10^9+7}$ and $10^9-1\equiv -8\pmod{10^9+7}$, the product is $(-7)(-8)=56$ and dividing by $2$ gives $28$. The rank pattern count is $g(2)=1$, so the answer is $28$.

This tests that the binomial coefficient is computed correctly using modular inverses when $K$ is large. More broadly, whenever $K=1$, any strict inequality is impossible, so the answer is always $0$. When the entire string is a single character repeated $n$ times, $d=n+1$ and the unique monotone rank pattern gives $g(n+1)=1$, so the answer is $\binom{K}{n+1}$ (or $0$ if $K<n+1$).

---

**[section_03]**
Try brute force enumeration and observe why it fails.
**[atomic_03_01]**
A direct attempt is to enumerate every array $a$ of length $n+1$ with entries in $[1,K]$. For each enumerated array, we check the $n$ inequalities from $s$ to decide validity.
**[atomic_03_02]**
For each valid array, we compute its cost by counting distinct values across all positions, track the smallest cost encountered, and count how many arrays achieve that smallest cost. This matches the problem definition exactly, making it conceptually straightforward.
**[atomic_03_03]**
The number of candidate arrays is $K^{n+1}$. Even if validity checking and distinct counting were optimized, the enumeration itself dominates, so runtime grows exponentially in $n$.
**[atomic_03_04]**
Given $n$ can be up to $250$, even tiny $K$ values produce astronomically many arrays. This makes the approach infeasible for all but trivial cases and unusable under the constraints.
**[atomic_03_05]**
This failure indicates we must count combinatorially rather than enumerate explicitly, and we need an approach that avoids exponential dependence on $n$.

Time complexity: $O(n)$ to read input; $O(nK^{n+1})$ to enumerate all $K^{n+1}$ candidate arrays and validate each in $O(n)$ time. Overall $O(nK^{n+1})$ time, $O(n)$ auxiliary space.

---

**[section_04]**
Count valid arrays with a value-based DP and identify memory/time limitations.
**[atomic_04_01]**
A natural next attempt is dynamic programming by last value. Let $\text{dp}[i][v]$ be the number of valid prefixes of length $i$ ending with value $v$, where $1 \le v \le K$ and $1 \le i \le n+1$. The final number of valid arrays (ignoring the minimum-cost requirement) would be $\sum_{v=1}^{K}\text{dp}[n+1][v]$.
**[atomic_04_02]**
Transitions follow strict inequalities. If the next symbol is $\texttt{"<"}$, then the next value must be larger:
$$
\text{dp}[i+1][v]=\sum_{u=1}^{v-1}\text{dp}[i][u].
$$
If the next symbol is $\texttt{">"}$, then:
$$
\text{dp}[i+1][v]=\sum_{u=v+1}^{K}\text{dp}[i][u].
$$
**[atomic_04_03]**
Computing each transition sum naively costs $O(K)$ per target $v$, so one DP layer update costs $O(K^2)$. Across $n$ transitions, total runtime becomes $O(nK^2)$.
**[atomic_04_04]**
This approach fails for two reasons: (1) $K$ can be as large as $10^9$, so storing even a single layer of size $K$ is impossible, and (2) $O(nK^2)$ operations are far beyond any feasible limit.
**[atomic_04_05]**
Even before integrating the “minimum number of distinct values” objective, the basic feasibility of this DP collapses under the constraints. We must avoid any algorithm that allocates or iterates over $\{1, \ldots, K\}$.

Time complexity: $O(n)$ to read input; $O(K)$ to initialize the DP table; $O(nK^2)$ for $n$ transition steps each filling $K$ states at $O(K)$ per state. Overall $O(nK^2)$ time, $O(K)$ memory with rolling arrays.

---

**[section_05]**
Explore prefix-sum optimization of the value-based DP.
**[atomic_05_01]**
We can improve the previous DP by noting that transitions are prefix sums or suffix sums. For $\texttt{"<"}$, each next state is a prefix sum of the previous states; for $\texttt{">"}$, it is a suffix sum.
**[atomic_05_02]**
With a running prefix sum, all $\text{dp}[i+1][v]$ for a $\texttt{"<"}$ step can be computed in a single sweep over $v=1,2,\ldots,K$. Similarly, a running suffix sum computes a $\texttt{">"}$ step in one sweep over $v=K,K-1,\ldots,1$.
**[atomic_05_03]**
This reduces each layer update to $O(K)$ time, so the DP becomes $O(nK)$ time and $O(K)$ memory (using rolling arrays). This is a strict improvement over $O(nK^2)$.
**[atomic_05_04]**
However, the constraints still make this impossible: $K$ can be $10^9$, so an $O(K)$ array cannot be stored, and $O(nK)$ operations are far too many. Additionally, since $K$ is provided as a number (not as a list of values), $O(K)$ work is not polynomial in the input length measured as $O(n+\log K)$.
**[atomic_05_05]**
This failure forces a shift in perspective: the strict comparisons depend on relative ordering rather than the absolute magnitudes of values in $[1,K]$. Any viable solution must avoid linear dependence on $K$.

Time complexity: $O(n)$ to read input; $O(K)$ to initialize the DP table; $O(nK)$ for $n$ transition steps each sweeping $K$ states in $O(K)$ via prefix/suffix sums. Overall $O(nK)$ time, $O(K)$ memory.

---

**[section_06]**
Reformulate the task using ranks and investigate polynomial-time counting.
**[atomic_06_01]**
To minimize the number of distinct brightness levels, we first need to understand the minimum possible distinct count forced by the string $s$. A contiguous run of $m$ identical symbols ($\texttt{"<"}$ or $\texttt{">"}$) forces a strictly monotone sequence of length $m+1$, which must contain $m+1$ distinct values.
**[atomic_06_02]**
Let $m$ be the maximum length of any contiguous run of identical characters in $s$, and define $d=m+1$. A strictly monotone sequence of length $m+1$ necessarily contains $m+1$ distinct values, so any valid array requires at least $d$ distinct values. To see that $d$ values also suffice, consider mapping each position to a rank in $\{1,\dots,d\}$ by greedily assigning the locally-forced ordering within each maximal run. At direction changes (where the symbol flips), the boundary position is a local extremum whose rank can be chosen from values already used in the adjacent segment. This construction achieves exactly $d$ distinct values, confirming that $c_{\min}=d$. If $K<d$, it is impossible to realize $d$ distinct values within $[1,K]$, so the answer is immediately $0$.
**[atomic_06_03]**
Assuming $K \ge d$, any minimum-cost array uses exactly $d$ distinct values. If we choose those $d$ brightness levels and sort them as $x_1<x_2<\dots<x_d$, then any valid array using exactly these values corresponds to a rank array $r$ where $r_i=j$ means $a_i=x_j$. Validity depends only on comparisons of neighbors, so it depends only on ranks, not the specific numeric choices of $x_j$.
**[atomic_06_04]**
This splits the counting into two independent parts:
1) choose which $d$ distinct brightness levels are used: $\binom{K}{d}$ ways,
2) count rank arrays over alphabet $\{1,\dots,d\}$ that satisfy $s$ and use all ranks at least once.
The second part is purely combinatorial in $n$ and $d$.
**[atomic_06_05]**
To enforce “all ranks are used” without tracking subsets explicitly, we introduce $f(M)$ = the number of valid rank arrays over alphabet $\{1,\dots,M\}$ where symbols may be unused. Then the number that uses all $d$ symbols is obtained by inclusion–exclusion:
$$
g(d)=\sum_{i=0}^{d}(-1)^i\binom{d}{i} f(d-i).
$$
A direct “track used symbols” DP would be exponential in $d$ and is discarded as infeasible.
**[atomic_06_06]**
A first implementation attempt for $f(M)$ uses a DP over the last rank, but computes each transition sum naively. For a fixed $M$, for each of the $n$ steps and each target rank $v$, summing over all smaller (or larger) previous ranks costs $O(M)$, leading to $O(nM^2)$ time per $M$.
**[atomic_06_07]**
Because inclusion–exclusion needs $f(1),f(2),\dots,f(d)$, total time becomes
$$
O\left(\sum_{M=1}^{d} nM^2\right)=O(nd^3)=O(n^4),
$$
since $d \le n+1$. This is polynomial and removes dependence on $K$, which is a major improvement over $O(nK)$, but $O(n^4)$ is still too slow in practice for $n \approx 250$.

Time complexity: $O(n)$ to read input and compute $d$ (scan $s$ for the longest run); $O(d)$ to build factorial and inverse-factorial tables (including one $O(\log p)$ modular exponentiation where $p=10^9+7$); $\sum_{M=1}^{d} O(nM^2)=O(nd^3)$ to compute all $f(M)$ values; $O(d)$ for inclusion–exclusion and $\binom{K}{d}$. Overall $O(nd^3)$ time per test case, $O(d)$ memory.

---

**[section_07]**
Investigate faster rank-DP transitions using prefix and suffix sums.
**[atomic_07_01]**
We keep the rank-based structure from the previous section (compute $d$, then $\binom{K}{d}$, then $g(d)$ via inclusion–exclusion) and focus on accelerating the computation of all $f(M)$ values.
**[atomic_07_02]**
For a fixed alphabet size $M$, define a 1D DP over the last rank: $\text{dp}[v]$ is the number of ways to build the current prefix ending at rank $v$ ($1 \le v \le M$). Initially, before processing any character of $s$, the first rank can be any value, so $\text{dp}[v]=1$ for all $v$.
**[atomic_07_03]**
For each character in $s$, we update $\text{dp}$ to $\text{ndp}$:
- if the character is $\texttt{"<"}$, then $\text{ndp}[v]=\sum_{u<v}\text{dp}[u]$,
- if it is $\texttt{">"}$, then $\text{ndp}[v]=\sum_{u>v}\text{dp}[u]$.
All computations are done modulo $10^9+7$.
**[atomic_07_04]**
The key optimization is to compute these sums with a single sweep:
- For $\texttt{"<"}$, maintain a running prefix sum while scanning $v=1,2,\ldots,M$, so each $\text{ndp}[v]$ is obtained in $O(1)$ amortized time.
- For $\texttt{">"}$, maintain a running suffix sum while scanning $v=M,M-1,\ldots,1$.
This reduces one step update from $O(M^2)$ to $O(M)$.
**[atomic_07_05]**
With this optimization, computing $f(M)$ takes $O(nM)$ time. Computing all $f(1),f(2),\ldots,f(d)$ takes
$$
O\left(\sum_{M=1}^{d} nM\right)=O(nd^2)=O(n^3),
$$
since $d \le n+1 \le 251$. This is a strict improvement over the previous section’s $O(nd^3)=O(n^4)$.
**[atomic_07_06]**
After obtaining all $f(M)$, we compute
$$
g(d)=\sum_{i=0}^{d}(-1)^i\binom{d}{i} f(d-i)
$$
carefully under modulo arithmetic, ensuring subtraction is normalized back into $[0,\text{MOD}-1]$. We also treat $f(0)=0$ (no symbols cannot form a positive-length array).
**[atomic_07_07]**
We compute $\binom{K}{d} \bmod \text{MOD}$ using the multiplicative formula with a small factorial:
$$
\binom{K}{d}=\frac{K(K-1)\cdots(K-d+1)}{d!}\pmod{\text{MOD}}.
$$
Because $d \le 251$, we can precompute $d!$ and its modular inverse; because $K<\text{MOD}$, the numerator product terms are well-defined modulo $\text{MOD}$.
**[atomic_07_08]**
The final answer per test case is
$$
\text{ans}=\binom{K}{d}\cdot g(d)\bmod \text{MOD},
$$
with an early output of $0$ if $K<d$. This completes the solution with manageable time and memory while correctly counting only minimum-cost valid arrays.

Time complexity: $O(n)$ to read input and compute $d$ (scan $s$ for the longest run); $O(d)$ to build factorial and inverse-factorial tables (including one $O(\log p)$ modular exponentiation where $p=10^9+7$); $\sum_{M=1}^{d} O(nM)=O(nd^2)$ to compute all $f(M)$ values; $O(d)$ for inclusion–exclusion and $\binom{K}{d}$. Overall $O(nd^2)$ time and $O(d)$ memory per test case, where $d \le n+1$.